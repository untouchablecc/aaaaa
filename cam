function Vnly_findNearestEnemy()
    local ClosestDistance, ClosestPlayer = math.huge, nil
    local CenterPosition = Vector2.new(game:GetService("GuiService"):GetScreenResolution().X / 2, game:GetService("GuiService"):GetScreenResolution().Y / 2)

    for _, Player in ipairs(game:GetService("Players"):GetPlayers()) do
        if Player ~= game.Players.LocalPlayer then
            local Character = Player.Character
            if Character and Character:FindFirstChild("HumanoidRootPart") and Character:FindFirstChild("Humanoid") and Character.Humanoid.Health > 0 then
                local Position, IsVisibleOnViewport = workspace.CurrentCamera:WorldToViewportPoint(Character.HumanoidRootPart.Position)
                if IsVisibleOnViewport then
                    local Distance = (CenterPosition - Vector2.new(Position.X, Position.Y)).Magnitude
                    if Distance < ClosestDistance then
                        ClosestPlayer = Character.HumanoidRootPart
                        ClosestDistance = Distance
                    end
                end
            end
        end
    end

    return ClosestPlayer
end

function Vnly_getPredictedPosition(Player)
    if not Player or not Player.Position then return Vector3.new(0, 0, 0) end -- Added safety check
    local velocity = Player.Velocity or Vector3.new(0, 0, 0)
    local predictedPosition = Player.Position + (velocity * Camlock.Prediction.Multiplier)
    return predictedPosition
end

function Vnly_GetShakedVector3(Intensity)
    return Vector3.new(math.random(-Intensity * 1e9, Intensity * 1e9), math.random(-Intensity * 1e9, Intensity * 1e9), math.random(-Intensity * 1e9, Intensity * 1e9)) / 1e9;
end

local enemyCamlock = nil
game:GetService("RunService").RenderStepped:Connect(function()
    if Camlock.Enabled and Camlock.Active and enemyCamlock and enemyCamlock.Parent and enemyCamlock.Parent:FindFirstChild("HumanoidRootPart") then
        local humanoidRootPart = enemyCamlock.Parent.HumanoidRootPart
        local predictedPosition = Vnly_getPredictedPosition(humanoidRootPart)

        local adjustedPosition = predictedPosition + Vector3.new(
            Camlock.Prediction.XOffset,
            Camlock.Prediction.YOffset,
            Camlock.Prediction.ZOffset
        ) + Vnly_GetShakedVector3(Camlock.Shake.Intensity)

        local camera = workspace.CurrentCamera
        local Main = CFrame.new(camera.CFrame.p, adjustedPosition)
        camera.CFrame = camera.CFrame:Lerp(Main, Camlock.Aimbot.CameraSmoothing, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut)
    else
        -- Optionally reset the camera when enemyCamlock is nil or inactive
        -- camera.CFrame = CFrame.new(camera.CFrame.Position)
    end
end)

local UIS = game:GetService("UserInputService")
UIS.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == Camlock.Key then
        Camlock.Active = not Camlock.Active

        if Camlock.Active then
            enemyCamlock = Vnly_findNearestEnemy()
            if enemyCamlock and Camlock.NOTIF then
                game.StarterGui:SetCore("SendNotification", {
                    Title = "Camlock",
                    Text = "Locked on: " .. tostring(enemyCamlock.Parent.Name),
                    Icon = "http://www.roblox.com/asset/?id=8850953349",
                    Duration = 1,
                })
            end
        else
            enemyCamlock = nil
            if Camlock.NOTIF then
                game.StarterGui:SetCore("SendNotification", {
                    Title = "Camlock",
                    Text = "Unlocked Camlock",  -- Consider changing to "No Target Locked" if enemyCamlock is nil
                    Icon = "http://www.roblox.com/asset/?id=8850953349",
                    Duration = 1,
                })
            end
        end
    end
end)
local holding = false
local autoShootActive = false
local autoShootRunning = false

-- Function to handle shooting logic
local function autoShoot()
    autoShootRunning = true
    while autoShootActive and AutoShoot.Enabled do
        -- Trigger shooting action
        mouse1click()  -- Simulate left mouse click to shoot
        wait(AutoShoot.Delay)  -- Apply the delay between shots
    end
    autoShootRunning = false
end

-- Function to handle Toggle and Hold mode
local function handleAutoShoot()
    if AutoShoot.Mode == "Toggle" then
        autoShootActive = not autoShootActive  -- Toggle the state
        if autoShootActive and not autoShootRunning then
            spawn(autoShoot)
        end
        if AutoShoot.NOTIF then
            game.StarterGui:SetCore("SendNotification", {
                Title = "AutoShoot",
                Text = autoShootActive and "Enabled" or "Disabled",
                Duration = 2
            })
        end
    elseif AutoShoot.Mode == "Hold" then
        if holding and not autoShootRunning then
            autoShootActive = true
            spawn(autoShoot)
        elseif not holding then
            autoShootActive = false
        end
    end
end

-- Handle key press
game:GetService("UserInputService").InputBegan:Connect(function(input, gameProcessed)
    if not gameProcessed and input.KeyCode == AutoShoot.Key and AutoShoot.Enabled then
        if AutoShoot.Mode == "Hold" then
            holding = true
            handleAutoShoot()
        elseif AutoShoot.Mode == "Toggle" then
            handleAutoShoot()  -- Toggle mode
        end
    end
end)

-- Handle key release for Hold mode
game:GetService("UserInputService").InputEnded:Connect(function(input)
    if input.KeyCode == AutoShoot.Key and AutoShoot.Mode == "Hold" and AutoShoot.Enabled then
        holding = false
        handleAutoShoot()
    end
end)
